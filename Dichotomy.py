def f(x):
    return x**4+2*x**3-x-1

def dichotomy(a,b,eps):#метод не применим если в уравнении больше 1 корня 

    fa=f(a);fb=f(b)#чтобы каждый раз не вызывать функцию f(x)

    if fa*fb<0:#тогда корень находится между а и b
        x=(a+b)/2
        fx=f(x)
    else:#график функции на этом интервале не пересекает ось OX
        return print('This interval has no root of the equation')

    while abs(a-b)>eps:#abs(a-b) есть длинна отрезка аb на котором лежит корень урав., когда это значение станет <= заданной точности eps (эпсилон) считаем что мы достигли точности eps , которая задается в отрицательных степенях 10 , к примеру 0,001
        if fa*fx<0:#тогда корень находится между а и х
            b=x;fb=fx#задаем более близкое к корню значение для b , и более близкое к f(0) значение для f(b)
        elif fb*fx<0:#если fa*fx>0 то fb*fx<0
            a=x;fa=fx
        else:#если не удовлетворяется fa*fx<0 и fb*fx<0 то учитывая условие fa*fb<0 , знаем что соответственно эквивалентные им условия fb*fx>0 и fa*fx>0 также не удовлетворяются , значит при этом возможно только fa*fx=fb*fx=0 , опять же учитывая fa*fb<0 , ясно что fx=0 , отсюда : х-корень уравнения
            return print('x=',x,'is root of the equation')
        x=(a+b)/2
        fx=f(x)

    if abs(fa)<abs(fb):#если модуль fa меньше то fa ближе к f(x)=0 , то есть а ближе к корню уравнения
        print('x=',a,'is approximate root of the equation')
    else:
        print('x=',b,'is approximate root of the equation')

dichotomy(0,1,0.001)





